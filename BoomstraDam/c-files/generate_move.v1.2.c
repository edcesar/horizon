/*
  This file is Copyright (C) 2010 Feike Boomstra.
  Distributed under the Boost Software License, Version 1.0.
  (See accompanying file LICENSE_1_0.txt or copy at
  http://www.boost.org/LICENSE_1_0.txt)
*/


#undef _DEBUG
#include "Python.h"
#include "BoomstraDam.v1.2.h"

/*
This is the c-module for the (international)draught program BoomstraDam.
The user interaction is written in python, the cpu / memory intensive part is written in c

The best move is generated by: alphabeta pruning using the MTD(f) algoritm, a legal move generator and an evaluation function.

The best move is returned as a string too:
start stop cap1 cap2 ... where start is the two digit start position, stop ... and capx is the x-th captured piece (all two digits)

Internal the board position is numbered 0..49, so one less than the external numbering.
The knowledge about the relation between the fields is kept in 4 "direction" arrays: nw, ne, sw, se and pnw, pne, pse, pse.
E.g. *psw[3] gives the next field in south west direction of field 3, this is field 8 (external of course: 4 and 9)

These arrays are used to create the legal move(s).


Feike Boomstra, Ter Apel, March 2006.
*/

static PyObject *callback_function = NULL;                               /* to save the call back function for checking whether it is time to go */
const char *s;					                                         /* to receive the board position from python */

static PyObject *foreground_c_best_move(PyObject *self, PyObject *args)  /* This is the main call from pyhon to c */
{
	if (PyArg_ParseTuple(args, "s", &s)) {
	} else {
		PyErr_SetString(PyExc_TypeError, "parameter must be a string");
		return NULL;
	};
	return Py_BuildValue("s", get_best_move(s));		// returns a string with the best move and value								

}; 

static PyObject *generatemove_analyse_position(PyObject *self, PyObject *args)  /* This is to evaluate all legal moves in each position */
{
	if (PyArg_ParseTuple(args, "s", &s)) {
	} else {
		PyErr_SetString(PyExc_TypeError, "parameter must be a string");
		return NULL;
	};
	return Py_BuildValue("s", compare_calc_move_with_played_move(s));		// returns a string with the moves and values								

}; 

static PyObject *generatemove_evaluate_position(PyObject *self, PyObject *args)  /* This is to evaluate all legal moves in each position */
{
	if (PyArg_ParseTuple(args, "s", &s)) {
	} else {
		PyErr_SetString(PyExc_TypeError, "parameter must be a string");
		return NULL;
	};
	return Py_BuildValue("s", evaluate_board_position(s));	

}; 


static PyObject *generatemove_analyse_timing(PyObject *self, PyObject *args)  /* This is to evaluate all legal moves in one position */
{
	if (PyArg_ParseTuple(args, "s", &s)) {
	} else {
		PyErr_SetString(PyExc_TypeError, "parameter must be a string");
		return NULL;
	};
	return Py_BuildValue("s", analyse_timing(s));		// returns a string with the moves and values								

}; 

static PyObject * generatemove_get_move_from_opening_book(PyObject *self, PyObject *args)  /* This is to obtain a move fro the openings books */
{
	if (PyArg_ParseTuple(args, "s", &s)) {
	} else {
		PyErr_SetString(PyExc_TypeError, "parameter must be a string");
		return NULL;
	};
	return Py_BuildValue("s", get_move_from_opening_book(s));		// returns a string with the move								

}; 

static PyObject *report_now(PyObject *self, PyObject *args)  /* This is the final report call from pyhon to c */
{
	
	create_final_report(); 
	Py_INCREF(Py_None);							/* just ok return with no parameters */
	return Py_None;								

}; 

static PyObject * background_c_best_move(PyObject *self, PyObject *args)
{
	/* the function uses the opponents time to expand the best-move-tree
	   it must call periodicaly the call back function to check whether
	   the opponent has moved.
    */
	int continue_flag;			/* to register whether we have to stop computing */
	int arg = 127;				/* fake variable, because I don't know how to call the callback function without parameters */
	PyObject *arglist;			/* the argument list for the call back function */
    PyObject *result;			/* the result of the call back function (as python object */
	arglist = Py_BuildValue("(i)", arg);						/* build the fake arglist */

	while (1)					/* do forever */
	{
		result = PyEval_CallObject(callback_function, arglist); /* call back python */
		if (result != NULL)										/* call back was sucsesfull */
		{
			if (PyArg_Parse(result, "i", &continue_flag))		/* convert the result to c variable*/
			{
				Py_DECREF(result);								/* we don't use result any more */
				if (continue_flag)								/* may we go on ?? */
				{
					/* continue background processing */
				} else
				{
					/* return to program's main loop (in play_mode) */
					Py_DECREF(arglist);							/* arglist no longer in use */
					Py_INCREF(Py_None);							/* just ok return with no parameters */
					return Py_None;								
				}
			} else
			{
				PyErr_SetString(PyExc_TypeError, "invalid return value from background");
				Py_DECREF(arglist);								/* arglist no longer in use */
				Py_DECREF(result);
				return NULL;									/* (internal) error return */
			}
		} else
		{
			Py_DECREF(arglist);									/* arglist no longer in use */
			return NULL;
		}
	}
}

static PyObject * init_c_best_move(PyObject *self, PyObject *args)
{
	init_game();
	Py_INCREF(Py_None);
	return Py_None;
}
static PyObject *set_callback(PyObject *dummy, PyObject *args)
{
    PyObject *result = NULL;
    PyObject *temp;

    if (PyArg_ParseTuple(args, "O:set_callback", &temp)) {
        if (!PyCallable_Check(temp)) {
            PyErr_SetString(PyExc_TypeError, "parameter must be callable");
            return NULL;
        }
		Py_XINCREF(temp);         /* Add a reference to new callback */
		Py_XDECREF(callback_function);  /* Dispose of previous callback */
		callback_function = temp;       /* Remember new callback */
			/* Boilerplate to return "None" */
		Py_INCREF(Py_None);
		result = Py_None;
	}
	return result;
}


static PyMethodDef generate_move_methods[] = {
	{"foreground_c_best_move", foreground_c_best_move, 1, "generate the best move (player = computer)"},
	{"background_c_best_move", background_c_best_move, 1, "continue in other players time"},
	{"init_c_best_move", init_c_best_move, 1, "reset the environment"},
	{"set_call_back", set_callback, 1, "provide the function to be called back later"},
	{"report_now", report_now, 1, "generate a final report"},
	{"analyse_position", generatemove_analyse_position, 1, "generate the value of the moves in this position"},
	{"get_move_from_opening_book", generatemove_get_move_from_opening_book, 1, "get move from opening book"},
	{"analyse_timing", generatemove_analyse_timing, 1, "analyse_board_position"},
	{"evaluate_position", generatemove_evaluate_position, 1, "evaluate board position"},
	{NULL, NULL, 0, NULL}
};

PyMODINIT_FUNC initgenerate_move(void)
{
	(void) Py_InitModule("generate_move", generate_move_methods);
}

/*	int continue_flag;			/* to register whether we have to stop computing */
/*	int arg = 127;				/* fake variable, because I don't know how to call the callback function without parameters */
/*	PyObject *arglist;			/* the argument list for the call back function */
/*    PyObject *result;			/* the result of the call back function (as python object */

	/*	arglist = Py_BuildValue("(i)", arg);						/* build the fake arglist */

/*	while (1)					/* do forever */
/*	{
/*		result = PyEval_CallObject(callback_function, arglist); /* call back python */
/*		if (result != NULL)										/* call back was sucsesfull */
/*		{
/*			if (PyArg_Parse(result, "i", &continue_flag))		/* convert the result to c variable*/
/*			{
/*				Py_DECREF(result);								/* we don't use result any more */
/*				if (continue_flag)								/* may we go on ?? */
/*				{
					/* continue foreground processing */
/*				} else
				{
					/* return to program's main loop (in play_mode) */
/*					Py_DECREF(arglist);							/* arglist no longer in use */
/*					Py_INCREF(Py_None);							/* just ok return with no parameters */
/*					return Py_None;								
				}
			} else
			{
				PyErr_SetString(PyExc_TypeError, "invalid return value from background");
				Py_DECREF(arglist);								/* arglist no longer in use */
/*				Py_DECREF(result);
				return NULL;									/* (internal) error return */
/*			}
/*		} else
		{
			Py_DECREF(arglist);									/* arglist no longer in use */
/*			return NULL;
		}
	} */
	/* Stuff for later, call back, now something more simple */
